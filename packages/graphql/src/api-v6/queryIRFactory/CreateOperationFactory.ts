/*
 * Copyright (c) "Neo4j"
 * Neo4j Sweden AB [http://neo4j.com]
 *
 * This file is part of Neo4j.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import Cypher from "@neo4j/cypher-builder";
import type { Neo4jGraphQLSchemaModel } from "../../schema-model/Neo4jGraphQLSchemaModel";
import type { ConcreteEntity } from "../../schema-model/entity/ConcreteEntity";
import { QueryAST } from "../../translate/queryAST/ast/QueryAST";

import type { AttributeAdapter } from "../../schema-model/attribute/model-adapters/AttributeAdapter";
import { ConcreteEntityAdapter } from "../../schema-model/entity/model-adapters/ConcreteEntityAdapter";
import { PropertyInputField } from "../../translate/queryAST/ast/input-fields/PropertyInputField";
import { V6CreateOperation } from "../queryIR/CreateOperation";
import { ReadOperationFactory } from "./ReadOperationFactory";
import type { GraphQLTreeCreate, GraphQLTreeCreateInput } from "./resolve-tree-parser/graphql-tree/graphql-tree";

export class CreateOperationFactory {
    public schemaModel: Neo4jGraphQLSchemaModel;
    private readFactory: ReadOperationFactory;

    constructor(schemaModel: Neo4jGraphQLSchemaModel) {
        this.schemaModel = schemaModel;
        this.readFactory = new ReadOperationFactory(schemaModel);
    }

    public createAST({
        graphQLTreeCreate,
        entity,
    }: {
        graphQLTreeCreate: GraphQLTreeCreate;
        entity: ConcreteEntity;
    }): QueryAST {
        const operation = this.generateCreateOperation({
            graphQLTreeCreate,
            entity,
        });
        return new QueryAST(operation);
    }

    private generateCreateOperation({
        graphQLTreeCreate,
        entity,
    }: {
        graphQLTreeCreate: GraphQLTreeCreate;
        entity: ConcreteEntity;
    }): V6CreateOperation {
        const topLevelCreateInput = graphQLTreeCreate.args.input;
        const targetAdapter = new ConcreteEntityAdapter(entity);
        const unwindCreate = this.parseTopLevelCreate({
            target: targetAdapter,
            createInput: topLevelCreateInput,
            argumentToUnwind: new Cypher.Param(topLevelCreateInput),
        });
        if (graphQLTreeCreate.fields) {
            const projection = this.readFactory.generateMutationOperation({
                graphQLTreeNode: graphQLTreeCreate,
                entity,
            });
            unwindCreate.addProjectionOperations([projection]);
        }
        return unwindCreate;
    }

    private parseTopLevelCreate({
        target,
        createInput,
        argumentToUnwind,
    }: {
        target: ConcreteEntityAdapter;
        createInput: GraphQLTreeCreateInput[];
        argumentToUnwind: Cypher.Property | Cypher.Param;
    }): V6CreateOperation {
        const unwindCreate = new V6CreateOperation({
            target,
            argumentToUnwind,
        });

        this.hydrateUnwindCreateOperation({
            target,
            createInput: createInput,
            unwindCreate,
        });

        return unwindCreate;
    }

    private hydrateUnwindCreateOperation({
        target,
        createInput,
        unwindCreate,
    }: {
        target: ConcreteEntityAdapter;
        createInput: GraphQLTreeCreateInput[];
        unwindCreate: V6CreateOperation;
    }) {
        // TODO: Add autogenerated fields
        createInput.forEach((inputItem) => {
            for (const key of Object.keys(inputItem)) {
                const attribute = getAttribute(target, key);

                const attachedTo = "node";
                const inputField = this.parseAttributeInputField({
                    attribute,
                    unwindCreate,
                    attachedTo,
                });
                if (!inputField) {
                    continue;
                }
                unwindCreate.addField(inputField, attachedTo);
            }
        });
    }

    private parseAttributeInputField({
        attribute,
        unwindCreate,
        attachedTo,
    }: {
        attribute: AttributeAdapter;
        unwindCreate: V6CreateOperation;
        attachedTo: "node" | "relationship";
    }): PropertyInputField | undefined {
        if (unwindCreate.getField(attribute.name, attachedTo)) {
            return;
        }

        return new PropertyInputField({
            attribute,
            attachedTo,
        });
    }
}

/**
 * Get the attribute from the entity, in case it doesn't exist throw an error
 **/
function getAttribute(entity: ConcreteEntityAdapter, key: string): AttributeAdapter {
    const attribute = entity.attributes.get(key);
    if (!attribute) {
        throw new Error(`Transpile Error: Input field ${key} not found in entity ${entity.name}`);
    }
    return attribute;
}

export class QueryParseError extends Error {}
