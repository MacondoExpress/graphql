[[schema-configuration-global-configuration]]
= Global Configuration

Through the schema configuration, it is possible to disable a type of operation for the whole type definitions and not on type by type basis.
For instance, if you want to avoid all the top-level aggregation operations to be generated and avoid redundancy, Neo4j GraphQL Library allows using schema extensions with `@query`, `@mutation`, and `@subscription`:

[source, graphql, indent=0]
----
type Movie { 
    title: String 
    actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN) 
} 

type Actor { 
    name: String 
    movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT) 
}
extend schema @query(read: true, aggregate: false)
----

**Query**

    * `movies`
    * [.line-through]#`moviesAggregate`#
    * `moviesConnection`
    * `actors`
    * [.line-through]#`actorsAggregate`#
    * `actorsConnection`


**Invalid schema usage**

The same schema configuration directive cannot be applied to both Schema and Object.

Take the following type definitions as example:
[source, graphql, indent=0]
----
type Movie { 
    title: String 
    actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN) 
} 

type Actor @query(read: false, aggregate: true) { 
    name: String 
    movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT) 
}
extend schema @query(read: true, aggregate: false)
----

Such configuration will prompt the error `"@query directive already defined at the schema location"`.
