[[schema-configuration-field-configuration]]
= Field Configuration

It may be necessary to remove fields from being present in a GraphQL Object Type or a GraphQL Input Object Type.
For instance, let's consider the following type definitions:

[source, graphql, indent=0]
----
type Movie {
    title: String!
    description: String
}

type Actor {
    name: String!
    age: Int
    actedIn: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

The type `Actor` generated from the above.

[source, graphql, indent=0]
----
type Actor {
  name: String!
  age: Int
  actedIn(where: MovieWhere, options: MovieOptions, directed: Boolean = true): [Movie!]!
  actedInAggregate(where: MovieWhere, directed: Boolean = true): ActorMovieActedInAggregationSelection
  actedInConnection(where: ActorActedInConnectionWhere, first: Int, after: String, directed: Boolean = true, sort: [ActorActedInConnectionSort!]): ActorActedInConnection!
}
----

Using the directives `@selectable`, `@settable`, and `@relationship` is possible to control how these fields are exposed.
For instance, to not expose the field `age` in the Selection Set, by the type `Actor`, is possible to use the `@selectable` directive as follow:

[source, graphql, indent=0]
----
type Movie {
    title: String!
    description: String
}

type Actor {
    name: String!
    age: Int @selectable(onRead: false, onAggregate: false)
    actedIn: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT)
}
----

The type `Actor` is now:

[source, graphql, indent=0]
----
type Actor {
  name: String!
  actedIn(where: MovieWhere, options: MovieOptions, directed: Boolean = true): [Movie!]!
  actedInAggregate(where: MovieWhere, directed: Boolean = true): ActorMovieActedInAggregationSelection
  actedInConnection(where: ActorActedInConnectionWhere, first: Int, after: String, directed: Boolean = true, sort: [ActorActedInConnectionSort!]): ActorActedInConnection!
}
----

== `@selectable`

This directive controls if the field will be available on queries and aggregations. 

It has two arguments:

* **onRead**: If disabled, this field will not be available on queries and subscriptions.
* **onAggregation**: If disabled, aggregations will not be available for this field

=== Definition

[source, graphql, indent=0]
----
"""Instructs @neo4j/graphql to generate this field for selectable fields."""
directive @selectable(onRead: Boolean! = true, onAggregate: Boolean! = true) on FIELD_DEFINITION
----

=== Usage

With the following definition:

[source, graphql, indent=0]
----
type Movie {
    title: String!
    description: String @selectable(onRead: false, onAggregate: true)
}
----

The type `Movie` in the resulting schema will look:

[source, graphql, indent=0]
----
type Movie {
    title: String!
}
----

This means that descriptions cannot be queries, neither on top or on nested levels. Aggregations, however, are available for both:
[source, graphql, indent=0]
----
type MovieAggregateSelection {
    count: Int!
    description: StringAggregateSelectionNullable!
    title: StringAggregateSelectionNonNullable!
}
----

== `@settable`

This directive controls if the input field will be available on creation and update mutations.

It has two arguments:

* **onCreate**: If disabled, this field will not be available to be set on creation.
* **onUpdate**: If disabled, this field will not be available to be set on update.

=== Definition

[source, graphql, indent=0]
----
"""Instructs @neo4j/graphql to generate this input field for mutation."""
directive @settable(onCreate: Boolean! = true, onUpdate: Boolean! = true) on FIELD_DEFINITION
----

==== Usage

With this definition:

[source, graphql, indent=0]
----
type Movie {
    title: String!
    description: String @settable(onCreate: true, onUpdate: false)
}
----

The following input fields will be generated:

[source, graphql, indent=0]
----
input MovieCreateInput {
    description: String
    title: String!
}

input MovieUpdateInput {
    title: String
}
----

This means the description can be set on creation, but it will not be available for update operations.

=== `@settable` with Relationships
Settable can be used along with relationship fields. When an operation over a field is disabled this way, that relationship won't be available on top level operations. For example:

[source, graphql, indent=0]
----
type Movie {
    title: String!
    description: String
}

type Actor {
    name: String!
    actedIn: [Movie!]!
        @relationship(type: "ACTED_IN", direction: OUT)
        @settable(onCreate: false, onUpdate: true)
}
----

In this case this query is invalid, as the field `actedIn` is not available for `createActors`:

[source, graphql, indent=0]
----
mutation {
  createActors(input: { actedIn: { create: { node: { title: "ABC" } } } }) {
    actors {
      name
    }
  }
}
----

== `@relationship`

It's possible to control the schema produces by a `@relationship` directive.

=== Definition

[source, graphql, indent=0]
----
enum ExcludeOperation {
    CREATE
    READ
    UPDATE
    DELETE
    SUBSCRIBE
}

"""Instructs @neo4j/graphql to exclude the specified operations from query, mutation and subscription generation. If used without an argument, no queries, mutations or subscriptions will be generated for this type."""
directive @exclude(
    operations: [ExcludeOperation!]! = [CREATE, READ, UPDATE, DELETE, SUBSCRIBE]
) on OBJECT
----

=== Usage

==== Disable Query field generation

[source, graphql, indent=0]
----
type Actor @exclude(operations: [READ]) {
    name: String
}
----

==== Disable single Mutation field generation

[source, graphql, indent=0]
----
type Actor @exclude(operations: [CREATE]) {
    name: String
}
----

==== Disable multiple Mutation field generation

[source, graphql, indent=0]
----
type Actor @exclude(operations: [CREATE, DELETE]) {
    name: String
}
----

==== Disable Subscription field generation

[source, graphql, indent=0]
----
type Actor @exclude(operations: [SUBSCRIBE]) {
    name: String
}
----

==== Disable all Query, Mutation and Subscription field generation

The following two type definitions are equivalent in the fact that no queries, mutations or subscriptions will be generated for either of them:

[source, graphql, indent=0]
----
type Actor @exclude {
    name: String
}
----

[source, graphql, indent=0]
----
type Actor @exclude(operations: [CREATE, READ, UPDATE, DELETE, SUBSCRIBE]) {
    name: String
}
----

== `@readonly`

NOTE: label:deprecated[] **@readonly** directive is deprecated. Please use the xref::type-definitions/schema-configuration/field-configuration.adoc#_settable[`@settable`] directive.

The field will only feature in mutations for creating, and object types for querying, and will not be mutable after creation.

=== Definition

[source, graphql, indent=0]
----
"""Instructs @neo4j/graphql to only include a field in generated input type for creating, and in the object type within which the directive is applied."""
directive @readonly on FIELD_DEFINITION
----


== `@writeonly`

NOTE: label:deprecated[] **@writeonly** directive is deprecated. Please use the xref::type-definitions/schema-configuration/field-configuration.adoc#_selectable[`@selectable`] directive.

This field will only feature in input types, and will not be available for querying the object type through a Query or through a Mutation response.

=== Definition

[source, graphql, indent=0]
----
"""Instructs @neo4j/graphql to only include a field in the generated input types for the object type within which the directive is applied, but exclude it from the object type itself."""
directive @writeonly on FIELD_DEFINITION
----
