[[type-definitions-access-control]]
= Access Control

This page addresses controlling schema generation output through the inclusion/exclusion of fields.

For fine-grained and role-based access control, see xref::auth/index.adoc[Auth].

[[type-definitions-access-control-exclude]]
== `@exclude`

This directive skips the generation of queries and/or subscriptions and/or particular/all mutations for the specified type.

=== Definition

[source, graphql, indent=0]
----
enum ExcludeOperation {
    CREATE
    READ
    UPDATE
    DELETE
    SUBSCRIBE
}

"""Instructs @neo4j/graphql to exclude the specified operations from query, mutation and subscription generation. If used without an argument, no queries, mutations or subscriptions will be generated for this type."""
directive @exclude(
    operations: [ExcludeOperation!]! = [CREATE, READ, UPDATE, DELETE, SUBSCRIBE]
) on OBJECT
----

=== Usage

==== Disable Query field generation

[source, graphql, indent=0]
----
type User @exclude(operations: [READ]) {
    name: String
}
----

==== Disable single Mutation field generation

[source, graphql, indent=0]
----
type User @exclude(operations: [CREATE]) {
    name: String
}
----

==== Disable multiple Mutation field generation

[source, graphql, indent=0]
----
type User @exclude(operations: [CREATE, DELETE]) {
    name: String
}
----

==== Disable Subscription field generation

[source, graphql, indent=0]
----
type User @exclude(operations: [SUBSCRIBE]) {
    name: String
}
----

==== Disable all Query, Mutation and Subscription field generation

The following two type definitions are equivalent in the fact that no queries, mutations or subscriptions will be generated for either of them:

[source, graphql, indent=0]
----
type User @exclude {
    name: String
}
----

[source, graphql, indent=0]
----
type User @exclude(operations: [CREATE, READ, UPDATE, DELETE, SUBSCRIBE]) {
    name: String
}
----

[[type-definitions-access-control-readonly]]
== `@readonly`

The field will only feature in mutations for creating, and object types for querying, and will not be mutable after creation.

=== Definition

[source, graphql, indent=0]
----
"""Instructs @neo4j/graphql to only include a field in generated input type for creating, and in the object type within which the directive is applied."""
directive @readonly on FIELD_DEFINITION
----

[[type-definitions-access-control-writeonly]]
== `@writeonly`

This field will only feature in input types, and will not be available for querying the object type through a Query or through a Mutation response.

=== Definition

[source, graphql, indent=0]
----
"""Instructs @neo4j/graphql to only include a field in the generated input types for the object type within which the directive is applied, but exclude it from the object type itself."""
directive @writeonly on FIELD_DEFINITION
----

[[type-definitions-access-control-selectable]]
== `@selectable`

This directive controls if the field will be available on queries and aggregations. 

It has two arguments:

* onRead: If disabled, this field will not be available on queries and subscriptions.
* onAggregation: If disabled, aggregations will not be available for this field


=== Definition

[source, graphql, indent=0]
----
"""Instructs @neo4j/graphql to generate this field for selectable fields."""
directive @selectable(onRead: Boolean! = true, onAggregate: Boolean! = true) on FIELD_DEFINITION
----

=== Usage

With the following definition:

[source, graphql, indent=0]
----
type Movie {
    title: String!
    description: String @selectable(onRead: false, onAggregate: true)
}
----

The type `Movie` in the resulting schema will look:

[source, graphql, indent=0]
----
type Movie {
    title: String!
}
----

This means that descriptions cannot be queries, neither on top or nested levels. Aggregations, however, are available for both:

[source, graphql, indent=0]
----
type MovieAggregateSelection {
    count: Int!
    description: StringAggregateSelectionNullable!
    title: StringAggregateSelectionNonNullable!
}
----

[[type-definitions-access-control-settable]]
== `@settable`

This directive controls if the input field will be available on creation and update mutations.

It has two arguments:

* onCreate: If disabled, this field will not be available to be set on creation.
* onCreate: If disabled, this field will not be available to be set on update.

=== Definition

[source, graphql, indent=0]
----
"""Instructs @neo4j/graphql to generate this input field for mutation."""
directive @settable(onCreate: Boolean! = true, onUpdate: Boolean! = true) on FIELD_DEFINITION
----

=== Usage

With the following definition:

[source, graphql, indent=0]
----
type Movie {
    title: String!
    description: String @settable(onCreate: true, onUpdate: false)
}
----

The following input fields will be generated:

[source, graphql, indent=0]
----
input MovieCreateInput {
    description: String
    title: String!
}

input MovieUpdateInput {
    title: String
}
----

This means the description can be set on creation, but it will not be available for update operations.
