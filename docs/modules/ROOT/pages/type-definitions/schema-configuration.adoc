[[type-definitions-schema-configuration]]
= Schema Configuration

Neo4j GraphQL Library supports several functionalities like CRUD operations, aggregation, filtering, and many others.

To make them work, a large amount of GraphQL types are generated.

For instance, starting from the type definitions:

[source, graphql, indent=0]
----
type Movie { 
    title: String 
    actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN) 
} 

type Actor { 
    name: String 
    movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT) 
}
----
The library generates the following operation fields:

**Query**:

    * `movies`
    * `moviesAggregate`
    * `moviesConnection`
    * `actors`
    * `actorsAggregate`
    * `actorsConnection`

**Mutation**:

    * `createMovies`
    * `deleteMovies`
    * `updateMovies`
    * `createActors`
    * `deleteActors`
    * `updateActors`

**Subscription**:

    * `movieCreated`
    * `movieUpdated`
    * `movieDeleted`
    * `movieRelationshipCreated`
    * `movieRelationshipDeleted`
    * `actorCreated`
    * `actorUpdated`
    * `actorDeleted`
    * `actorRelationshipCreated`
    * `actorRelationshipDeleted`

In most cases, reducing the scope of the API is advisable. 
Neo4j GraphQL solves this problem by exposing directives that affect the schema generation phase.

This section instructs how to reduce the size of the schema, improve performance and limit access to unwanted operations.

== Usage

In case you want to prevent users from querying `actors` in the Neo4j database, you need to bring some changes to the initial type definitions:

[source, graphql, indent=0]
----
type Movie { 
    title: String 
    actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN) 
} 

type Actor @query(read: false, aggregate: false) { 
    name: String 
    movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT) 
}
----

With this change, the library does not generate the following operation fields from the Query root type:

**Query**:

    * `movies`
    * `moviesAggregate`
    * `moviesConnection`
    * [.line-through]#`actors`#
    * [.line-through]#`actorsAggregate`#
    * [.line-through]#`actorsConnection`#

=== Schema usage

You can disable an operation for the whole type definitions, and not only from some specific types.
This is the case when trying removing all the aggregate fields generated from both `actor` and `movie` Object types.

To avoid redundancy, Neo4j GraphQL Library allows specifying a global behavior by adding the schema configuration directive directly to the schema type:

[source, graphql, indent=0]
----
type Movie { 
    title: String 
    actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN) 
} 

type Actor { 
    name: String 
    movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT) 
}
extend schema @query(read: true, aggregate: false)
----

**Query**:

    * `movies`
    * [.line-through]#`moviesAggregate`#
    * `moviesConnection`
    * `actors`
    * [.line-through]#`actorsAggregate`#
    * `actorsConnection`


**Invalid schema usage**

A same schema configuration directive cannot be applied to both Schema and Object.

Consider the following type definitions as an example:
[source, graphql, indent=0]
----
type Movie { 
    title: String 
    actors: [Actor!]! @relationship(type: "ACTED_IN", direction: IN) 
} 

type Actor @query(read: false, aggregate: true) { 
    name: String 
    movies: [Movie!]! @relationship(type: "ACTED_IN", direction: OUT) 
}
extend schema @query(read: true, aggregate: false)
----

This will prompt the error `"@query directive already defined at the schema location"`.
